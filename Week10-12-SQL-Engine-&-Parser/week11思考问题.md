## Week11思考题

1. 数据库中都包含哪些文件，启动数据库时都需要加载哪些文件，从这些文件中需要恢复什么信息？

   

2. 使用Buffer的目的是为了尽可能的减少磁盘的IO次数，但是可能存在就算使用buffer依然存在大量磁盘IO的现象，出现这种情况的原因是什么，如何避免这种情况的发生？

答：当有大量读操作时，由于有一定概率不需要进行磁盘读操作，确实会减少磁盘的IO次数。  
1.如果有大量的写操作时，而刷新磁盘的策略为每次写操作都会把脏页面刷新到磁盘中时，磁盘IO依然会很大。  
a.一种策略是将每次刷磁盘改为定期刷磁盘，这样磁盘写操作会大大减少。  
b.还有一种策略是innoDB中的Change Buffer（写缓冲区），当对不在缓冲池中的非唯一普通索引页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中。  
[1]假如要修改页号为4的索引页，而这个页正好在缓冲池内  
![1](images/1.jfif)  
（1）直接修改缓冲池中的页，一次内存操作；  
（2）写入redo log，一次磁盘顺序写操作；  
[2]假如要修改页号为40的索引页，而这个页正好不在缓冲池内  
![2](images/2.jfif)  
（1）先把需要为40的索引页，从磁盘加载到缓冲池，一次磁盘随机读操作；  
（2）修改缓冲池中的页，一次内存操作；  
（3）写入redo log，一次磁盘顺序写操作；  
[3]假如要修改页号为40的索引页，而这个页正好不在缓冲池内  
![3](images/3.jfif)  
（1）在写缓冲中记录这个操作，一次内存操作；  
（2）写入redo log，一次磁盘顺序写操作；  
[4]假设稍后的一个时间，有请求查询索引页40的数据  
![4](images/4.jfif)  
（1）载入索引页，缓冲池未命中，这次磁盘IO不可避免；  
（2）从写缓冲读取相关信息；  
（3）恢复索引页，放到缓冲池LRU里；  
注：为什么写缓冲优化，仅适用于非唯一普通索引页呢？  
如果索引设置了唯一(unique)属性，在进行修改操作时，InnoDB必须进行唯一性检查。也就是说，索引页即使不在缓冲池，磁盘上的页读取无法避免，此时就应该直接把相应的页放入缓冲池再进行修改。  
2.有可能是替换策略有问题，这时需要对替换策略进行优化。  
3.buffer被换到了交换空间（虚拟内存）中，使得用户以为是在对内存操作，其实是对磁盘操作。  
策略：  
（1）Linux中设置值swappiness=0的时候表示最大限度使用物理内存，降低使用swap的可能性。
（2）当保证内存剩余要大于等于swap使用量时，通过重新挂载swap分区完成释放swap，这时所有存放在swap分区的文件都会转存到物理内存上。	 

	

3. 对当前的基于LRU的buffer有什么优化方式，除了LRU还有什么替换策略？



4. 通常情况下，一条数据从磁盘到被应用读取需要经过几次复制，有什么优化的手段？对buffer的设计产生了什么影响，有没有不使用buffer的数据库？



5. buffer中一个Page通常为16K，文件系统的读写单位为4K。如果在一个16K的page刷盘过程中出现宕机，造成该page只有部分刷盘，这种情况能否通过WAL恢复？如果不能有什么解决方法？



6. Page的大小是固定的，变长字段(`varchar`)如何存储，此时B+ Tree的page如何分裂与合并？

